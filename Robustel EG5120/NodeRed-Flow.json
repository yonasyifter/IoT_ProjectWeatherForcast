[{"id":"b46b2583b5273f4d","type":"modbus-read","z":"2030db3a94fae2e8","name":"","topic":"","showStatusActivities":false,"logIOActivities":false,"showErrors":false,"showWarnings":false,"unitid":"1","dataType":"HoldingRegister","adr":"0x100","quantity":"20","rate":"1","rateUnit":"s","delayOnStart":false,"startDelayTime":"","server":"f8dd83bd994476d2","useIOFile":false,"ioFile":"","useIOForPayload":false,"emptyMsgOnFail":true,"x":110,"y":120,"wires":[["6a2d58c0eef42b8e","55cf8efe2f1aa8a3"],[]]},{"id":"8dc757ae4689a002","type":"debug","z":"2030db3a94fae2e8","name":"debug 2","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":820,"y":100,"wires":[]},{"id":"6a2d58c0eef42b8e","type":"function","z":"2030db3a94fae2e8","name":"postprocessing","func":"let device_id = 101\nfunction uint32ToFloat(num) {\n    let buffer = new ArrayBuffer(4);\n    let intView = new Uint32Array(buffer);\n    let floatView = new Float32Array(buffer);\n    intView[0] = num;\n    var floatNumber = floatView[0];\n    return floatNumber;\n}\n\nconst dataDict = {\n    temperature: { offset: 0, wsize: 1, hookFn: (data) => { return data / 100 } },\n    humidity: { offset: 1, wsize: 1 },\n    light: { offset: 2, wsize: 1 },\n    noise: { offset: 3, wsize: 1 },\n    pressure: { offset: 4, wsize: 2, hookFn: uint32ToFloat },\n    tof: { offset: 6, wsize: 1 },\n    angle: { offset: 7, wsize: 1 },\n    accX: { offset: 8, wsize: 2, hookFn: uint32ToFloat },\n    accY: { offset: 10, wsize: 2, hookFn: uint32ToFloat },\n    accZ: { offset: 12, wsize: 2, hookFn: uint32ToFloat },\n    vibrAccX: { offset: 14, wsize: 2, hookFn: uint32ToFloat },\n    vibrAccY: { offset: 16, wsize: 2, hookFn: uint32ToFloat },\n    vibrAccZ: { offset: 18, wsize: 2, hookFn: uint32ToFloat },\n}\n\nfunction pasreData(arr, attrName, offset, wsize, hookFn) {\n    let value = null;\n    if (arr.length >= (offset + wsize)) {\n        if (wsize == 1) {\n            value = arr[offset];\n        } else if (wsize == 2) {\n            let lword = arr[offset] & 0xFFFF;\n            let hword = arr[offset + 1] & 0xFFFF;\n            value = (hword << 16) | lword;\n        } else {\n            return null;\n        }\n        if (hookFn) {\n            value = hookFn(value)\n        }\n    }\n    return value;\n}\n\nfunction processPayload(msg) {\n    if (Array.isArray(msg.payload)) {\n        let payload = { device_id: device_id };\n\n        \n        let arr = msg.payload;\n        for (let key in dataDict) {\n            payload[key] =\n                pasreData(arr,\n                    key,\n                    dataDict[key].offset,\n                    dataDict[key].wsize,\n                    dataDict[key].hookFn);\n        }\n        msg.payload = payload;\n    }\n    return msg;\n}\n\nreturn processPayload(msg);","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":300,"y":140,"wires":[["0c479825541181f1"]]},{"id":"0c479825541181f1","type":"function","z":"2030db3a94fae2e8","name":"Random Forest ML Prediction","func":"// Random Forest Weather Prediction Model\n// This is a simplified Random Forest implementation\n// For production, consider using a trained model from Python\n\n// Decision Tree structure (simplified)\nconst decisionTrees = [\n    // Tree 1\n    {\n        predict: function(data) {\n            if (data.humidity > 70) {\n                if (data.pressure < 1010) {\n                    return 'rainy';\n                } else if (data.temperature < 15) {\n                    return 'cloudy';\n                } else {\n                    return 'partly_cloudy';\n                }\n            } else {\n                if (data.temperature > 25) {\n                    return 'sunny';\n                } else {\n                    return 'clear';\n                }\n            }\n        }\n    },\n    // Tree 2\n    {\n        predict: function(data) {\n            if (data.pressure < 1005) {\n                if (data.humidity > 80) {\n                    return 'rainy';\n                } else {\n                    return 'cloudy';\n                }\n            } else if (data.pressure > 1020) {\n                if (data.humidity < 50) {\n                    return 'sunny';\n                } else {\n                    return 'partly_cloudy';\n                }\n            } else {\n                if (data.temperature > 20 && data.humidity < 60) {\n                    return 'sunny';\n                } else {\n                    return 'cloudy';\n                }\n            }\n        }\n    },\n    // Tree 3\n    {\n        predict: function(data) {\n            if (data.temperature < 10) {\n                if (data.humidity > 75) {\n                    return 'rainy';\n                } else {\n                    return 'cold_clear';\n                }\n            } else if (data.temperature > 28) {\n                return 'sunny';\n            } else {\n                if (data.pressure < 1012 && data.humidity > 65) {\n                    return 'rainy';\n                } else {\n                    return 'partly_cloudy';\n                }\n            }\n        }\n    },\n    // Tree 4\n    {\n        predict: function(data) {\n            if (data.humidity > 85) {\n                return 'rainy';\n            } else if (data.humidity < 40) {\n                return 'sunny';\n            } else {\n                if (data.light > 500) {\n                    return 'sunny';\n                } else {\n                    return 'cloudy';\n                }\n            }\n        }\n    },\n    // Tree 5\n    {\n        predict: function(data) {\n            if (data.pressure < 1008) {\n                if (data.temperature < 18) {\n                    return 'rainy';\n                } else {\n                    return 'cloudy';\n                }\n            } else {\n                if (data.humidity < 55 && data.temperature > 22) {\n                    return 'sunny';\n                } else {\n                    return 'partly_cloudy';\n                }\n            }\n        }\n    }\n];\n\n// Random Forest Prediction Function\nfunction randomForestPredict(sensorData) {\n    const predictions = [];\n    \n    // Get prediction from each tree\n    decisionTrees.forEach(tree => {\n        predictions.push(tree.predict(sensorData));\n    });\n    \n    // Majority voting\n    const votes = {};\n    predictions.forEach(pred => {\n        votes[pred] = (votes[pred] || 0) + 1;\n    });\n    \n    // Find the prediction with most votes\n    let maxVotes = 0;\n    let finalPrediction = 'unknown';\n    let confidence = 0;\n    \n    for (let prediction in votes) {\n        if (votes[prediction] > maxVotes) {\n            maxVotes = votes[prediction];\n            finalPrediction = prediction;\n        }\n    }\n    \n    confidence = (maxVotes / predictions.length) * 100;\n    \n    return {\n        prediction: finalPrediction,\n        confidence: confidence.toFixed(2),\n        votes: votes,\n        tree_predictions: predictions\n    };\n}\n\n// Additional weather condition classification\nfunction getWeatherDescription(prediction, data) {\n    const descriptions = {\n        'sunny': 'Clear sunny weather expected',\n        'partly_cloudy': 'Partly cloudy with some sunshine',\n        'cloudy': 'Overcast and cloudy conditions',\n        'rainy': 'Rain expected',\n        'clear': 'Clear skies',\n        'cold_clear': 'Cold but clear weather'\n    };\n    \n    return descriptions[prediction] || 'Weather condition unclear';\n}\n\n// Main prediction logic\nif (msg.payload && msg.payload.temperature !== null && msg.payload.humidity !== null) {\n    const mlResult = randomForestPredict(msg.payload);\n    \n    // Add ML prediction to the payload\n    msg.payload.ml_prediction = mlResult.prediction;\n    msg.payload.ml_confidence = mlResult.ml_confidence;\n    msg.payload.weather_description = getWeatherDescription(mlResult.prediction, msg.payload);\n    msg.payload.prediction_votes = mlResult.votes;\n    \n    // Store original sensor data\n    msg.payload.timestamp = new Date().toISOString();\n    \n    return msg;\n} else {\n    node.warn(\"Insufficient data for ML prediction\");\n    msg.payload.ml_prediction = \"insufficient_data\";\n    return msg;\n}","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":550,"y":140,"wires":[["8dc757ae4689a002","3d91e2b3504b5013"]]},{"id":"9725e0ebb423efe7","type":"comment","z":"2030db3a94fae2e8","name":"Weather Data from S6000U sensor with ML Prediction","info":"- Gather data from Robustel EG5120 gateway using Modbus\n- Preprocess the data using function\n- Apply Random Forest ML for weather prediction\n- Send final data with predictions to Database","x":450,"y":20,"wires":[]},{"id":"55cf8efe2f1aa8a3","type":"debug","z":"2030db3a94fae2e8","name":"debug 1","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":360,"y":60,"wires":[]},{"id":"ea4be0bc835f1fee","type":"inject","z":"2030db3a94fae2e8","name":"Query every 5 min","props":[{"p":"payload"}],"repeat":"5","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":190,"y":540,"wires":[["26534016ee0e601d"]]},{"id":"11aee9afc07ffe0f","type":"function","z":"2030db3a94fae2e8","name":"Format for Cloud","func":"// Extract temperature, pressure, humidity, and ML prediction from query results\nlet data = {};\n\nif (Array.isArray(msg.payload)) {\n    msg.payload.forEach(record => {\n        if (record._field === 'temperature') {\n            data.temperature = record._value;\n        } else if (record._field === 'pressure') {\n            data.pressure = record._value;\n        } else if (record._field === 'humidity') {\n            data.humidity = record._value;\n        } else if (record._field === 'ml_prediction') {\n            data.ml_prediction = record._value;\n        } else if (record._field === 'weather_description') {\n            data.weather_description = record._value;\n        }\n    });\n} else {\n    // Single record format\n    data[msg.payload._field] = msg.payload._value;\n}\n\n// Add device_id if needed\ndata.device_id = 101;\n\nmsg.payload = data;\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":630,"y":540,"wires":[["9cf5f379cec6f9e5","4e8e156080c11b73"]]},{"id":"9cf5f379cec6f9e5","type":"influxdb out","z":"2030db3a94fae2e8","influxdb":"fc05c283d7ec5771","name":"InfluxDB Cloud","measurement":"Sensor_S6000U_data2","precision":"ms","retentionPolicy":"","database":"","precisionV18FluxV20":"ms","retentionPolicyV18Flux":"","org":"90fe5af1cd03eaf7","bucket":"Weather_data","x":880,"y":580,"wires":[]},{"id":"ca0322b185a0f72a","type":"debug","z":"2030db3a94fae2e8","name":"Query Result","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":610,"y":480,"wires":[]},{"id":"4e8e156080c11b73","type":"debug","z":"2030db3a94fae2e8","name":"Cloud Data","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","x":850,"y":500,"wires":[]},{"id":"9bae929ed4b5e43b","type":"comment","z":"2030db3a94fae2e8","name":"Weather data forecast with ML and cloud sync","info":"Sensor data → ML prediction → Local DB → Cloud DB","x":470,"y":440,"wires":[]},{"id":"26534016ee0e601d","type":"robustel-influxdb in","z":"2030db3a94fae2e8","name":"Read Local DB","query":"from(bucket: \"bucket\")\n  |> range(start: -5m)\n  |> filter(fn: (r) => r._measurement == \"Sensor_S6000U_data\")\n  |> last()","rawOutput":false,"precision":"","retentionPolicy":"","org":"organisation","x":400,"y":540,"wires":[["11aee9afc07ffe0f","ca0322b185a0f72a"]]},{"id":"3d91e2b3504b5013","type":"robustel-influxdb out","z":"2030db3a94fae2e8","name":"Database","measurement":"S6000U_measurements","precision":"","retentionPolicy":"","database":"database","precisionV18FluxV20":"ms","retentionPolicyV18Flux":"","bucket":"bucket","x":820,"y":180,"wires":[]},{"id":"nmea_logic_parser","type":"function","z":"2030db3a94fae2e8","name":"NMEA to Decimal Degrees","func":"var line = msg.payload;\nif (line.includes(\"RMC\")) {\n    var p = line.split(\",\");\n    if (p[2] === \"A\") { // Check for valid fix\n        \n        // Convert NMEA DDMM.MMMM to Decimal Degrees\n        function toDecimal(coord, dir) {\n            var dot = coord.indexOf(\".\");\n            var deg = parseFloat(coord.substring(0, dot - 2));\n            var min = parseFloat(coord.substring(dot - 2));\n            var res = deg + (min / 60);\n            if (dir === \"S\" || dir === \"W\") res = -res;\n            return res.toFixed(6);\n        }\n\n        var latitude = toDecimal(p[3], p[4]);\n        var longitude = toDecimal(p[5], p[6]);\n\n        msg.payload = {\n            latitude: parseFloat(latitude),\n            longitude: parseFloat(longitude),\n            raw: line\n        };\n        return msg;\n    }\n}\nreturn null;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":480,"y":240,"wires":[[]]},{"id":"eg5120_gps_tcp","type":"tcp in","z":"2030db3a94fae2e8","name":"Robustel GPS Source","server":"client","host":"127.0.0.1","port":"12345","datamode":"stream","datatype":"utf8","newline":"\\n","topic":"","trim":false,"base64":false,"tls":"","x":160,"y":240,"wires":[["nmea_logic_parser"]]},{"id":"f8dd83bd994476d2","type":"modbus-client","name":"","clienttype":"serial","bufferCommands":true,"stateLogEnabled":true,"queueLogEnabled":false,"failureLogEnabled":true,"tcpHost":"127.0.0.1","tcpPort":"502","tcpType":"DEFAULT","serialPort":"/dev/ttyCOM1","serialType":"RTU","serialBaudrate":"115200","serialDatabits":"8","serialStopbits":"1","serialParity":"none","serialConnectionDelay":"1000","serialAsciiResponseStartDelimiter":"0x3A","unit_id":"1","commandDelay":"1","clientTimeout":"1000","reconnectOnTimeout":false,"reconnectTimeout":"1000","parallelUnitIdsAllowed":false,"showErrors":true,"showWarnings":true,"showLogs":true},{"id":"fc05c283d7ec5771","type":"influxdb","hostname":"us-east-1-1.aws.cloud2.influxdata.com","port":"443","protocol":"https","database":"","name":"InfluxDB Cloud","usetls":true,"tls":"","influxdbVersion":"2.0","url":"https://us-east-1-1.aws.cloud2.influxdata.com","timeout":"10","rejectUnauthorized":false}]